#!/bin/bash 
# Update:
# Mon Feb  5 11:27:32 CET 2018
#
# HGFlow - Host-Guest Molecular Dynamics Workflow 
# ... and Toy System Playground !!!
#
# Copyright (c) 2017 Diego Gomes and Marco Cecchini
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#  
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#  
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# -------------------------------------------------------------------
#
#   pdb = name of the original pdb file
#  host = list with host names
# guest = list with guest names
# 
#
# This will create the folders 
# 
# HOST-GUEST/structures/
# HOST-GUEST/top_gaff
# HOST-GUEST/top_gaff_resp/
# HOST-GUEST/solution/complex
# HOST-GUEST/solution/host
# HOST-GUEST/solution/guest
#

#
# How to use:
# Step 1 - Change what's necessary in the configuration below 
# Step 2 - Run this at the folder where you keep all complexes
# the must be named "host-guest.pdb". ex cb7-ad0.pdb, oah-o01.pdb ... 
# Step 3 - Smile


#
# Configuration -----------------------------------------------------
#

# Base directory
root=$PWD

# Folder with the original complexes
read -p "Original: " opt
original=${root}/${opt}/

# File containing charges for all complexes
charges_file=${root}/charges.txt

# Source Amber variables
#source $HOME/software/amber16/amber.sh
source /home/dgomes/software/amber16/amber.sh

# Use Mesocentre ?
SLURM="false"

# Put this in a command line.
run_host="false"
run_guest="true"

# Charge model
bcc="true"
resp="false"


# WARNING! - ATTENTION ! - ACHTUNG ! ATENCAO! - ATENCION ! UWAGA!
#
# Do not change anything below unless you know what you're doing.
# Ne modifiez rien ci-dessous, sauf si vous savez ce que vous faites.
# Ändern Sie nichts unter, wenn Sie nicht wissen, was Sie tun.
# Nao modifique nada abaixo, salvo se voce sabe o que faz.
# No cambie nada abajo a menos que sepa lo que está haciendo.
# Nie zmieniaj ponizszego kodu, jezeli nie jestes pewien co robisz.
# 
# WARNING! - ATTENTION ! - ACHTUNG ! ATENCAO! - ATENCION! UWAGA!



# Funcions ----------------------------------------------------------
#bash colors 
RED="\e[0;31m"
BLUE="\e[0;34m"
GREEN="\e[0;32m"
PURPLE="\e[0;35m"
NC="\033[0m"

welcome() {
echo -e "
------------------------------------------------------

${BLUE}HGFlow v0.3${NC} - ${PURPLE}Host/Guest Molecular Dynamics WorkFlow${NC}
  ${GREEN}Our Toy-System Playground !!!${NC} - Copyright 2017

                  Developed by
        Paulina Pacak(1), Nicolas Martin(2) 
     Marco Cecchini(2), Diego E. B. Gomes(1,2,3)

------------------------------------------------------
"
echo -ne "${RED}Loading${NC}"
for ((i=0;i<3;i++)) ; do echo -ne "." ; sleep 0.1 ; done
echo -ne "${BLUE}Done!${NC}\n\n" ; sleep 1
}


list_hosts() {
# 1) List all PDB files in the $root/$original/ folder
# 2) Split HOST and GUEST names
# 3) Create a list of big and small names only for HOST. 

# Folder list
cd ${original}
complex_list=$(ls *.pdb)

# Create a list of HOST
j=0
k=0
prev_host=""
for complex in ${complex_list} ; do
  stuff=$(echo ${complex} |cut -f1 -d-)

  if [ "${stuff}" != "${prev_host}" ] ; then

    host[${j}]=${stuff}
    HOST[$j]=$(echo ${stuff} | tr "[a-z]" "[A-Z]" )
    mkdir -p ${root}/parametrization/host/${HOST[$j]}
    grep " ${HOST[$j]} " ${complex} > ${root}/parametrization/host/${HOST[$j]}/${HOST[$j]}-original.pdb

    let j=${j}+1
  fi
  pdb[$k]=${complex}
  let k=${k}+1
  prev_host=${stuff}
done
}


list_guests() {
# 1) List all PDB files in the $root/$original/ folder
# 2) Split HOST and GUEST names
# 3) Create a list of big and small names only for GUESTs

# Folder list
cd ${original}
complex_list=$(ls *.pdb)

# Create a list of HOST
j=0
for complex in ${complex_list} ; do
  stuff=$(echo ${complex} |cut -f2 -d-)

  # Check if guest already exists on list
  k=0
  for val in ${guest[@]} ; do
    if [ "${stuff}" == "${val}" ] ; then k=1;  break ; fi
  done

  if [ ${k} -eq 0 ] ; then 
    guest[${j}]=${stuff} 
    GUEST[$j]=$(echo ${stuff} | tr "[a-z]" "[A-Z]" )
    mkdir -p ${root}/parametrization/guest/${GUEST[$j]}
    grep " ${GUEST[$j]} " ${complex} > ${root}/parametrization/guest/${GUEST[$j]}/${GUEST[$j]}-original.pdb
    let j=${j}+1
  fi

done
}



look_for_charge() {
#Read Host charges ----------------------------------------
while read a b ; do
  if [ $a == $1 ] ; then 
    charge=$b 
    break
  fi    
  charge="not found"
done < ${charges_file} 
}


parametrize() {
if [ "${run_host}" == "true" ] ; then
  system_type=host

  for mol in ${HOST[@]} ; do

    look_for_charge $mol
#  echo "Charge for $mol is $charge"

    if [ "${charge}" == "not found" ] ; then
      echo "Charge not found for $mol"
    else

      if [ "${resp}" == "true" ] ; then  
        mkdir -p ${root}/parametrization/host/${mol}/gaff_resp
        cd       ${root}/parametrization/host/${mol}/gaff_resp
        gen_resp 
      fi

      if [ "${bcc}"  == "true" ] ; then  
        mkdir -p ${root}/parametrization/host/${mol}/gaff_bcc
        cd       ${root}/parametrization/host/${mol}/gaff_bcc
        gen_bcc
      fi

    fi 
  done
fi 

if [ "${run_guest}" == "true" ] ; then
  system_type=guest

  for mol in ${GUEST[@]} ; do
    look_for_charge $mol

#  echo "Charge for $mol is $charge"
    if [ "${charge}" == "not found" ] ; then
      echo "Charge not found for $mol"
    else

      if [ "${resp}" == "true" ] ; then  
        mkdir -p ${root}/parametrization/guest/${mol}/gaff_resp
        cd       ${root}/parametrization/guest/${mol}/gaff_resp
        gen_resp 
      fi

      if [ "${bcc}"  == "true" ] ; then  
        mkdir -p ${root}/parametrization/guest/${mol}/gaff_bcc
        cd       ${root}/parametrization/guest/${mol}/gaff_bcc
        gen_bcc  
      fi
    fi
  done
fi 
}

gen_resp() {
  echo "Preparing RESP for ${mol}"
  if [ "${SLURM}" == "true"  ] ; then
   module load compilers/intel15
  fi

  # MOL2 to here just to rename residue.
  antechamber -fi pdb -fo mol2 -i ${root}/parametrization/${system_type}/${mol}/${mol}-original.pdb -o ${mol}-original.mol2 -at gaff -nc ${charge} &> pdb2mol2.log

  # MOL2 to Gaussian (GAFF atom types)
  antechamber -fi mol2 -fo gcrt -i ${mol}-original.mol2 -o ${mol}.gau -gv 1 -ge ${mol}.gesp -nc ${charge} -eq 2 -at gaff -gn "%nproc=8" -gm "%mem=16Gb" &>prepare_g09.log

  # Run Gaussian to optimize structure and generate electrostatic potential grid
  if [ "${SLURM}" == "true"  ] ; then 
    write_gaussian_slurm ${mol}
    sbatch ${mol}.slurm
  else
    g09 ${mol}.gau
  # Read Gaussian output and write new optimized ligand with RESP charges
    antechamber -fi gout -fo mol2 -i ${mol}.log -o ${mol}.mol2 -c resp -s 2 -at gaff -nc ${charge} -pl 20
    parmchk -i ${mol}.mol2  -f mol2 -o ${mol}.frcmod  &>parmchk.log
    write_top
  fi
}

gen_bcc() {
  echo "Preparing BCC for ${mol}"
  if [ "${SLURM}" == "true"  ] ; then
   module load compilers/intel15
  fi

  # MOL2 to here just to rename residue.
  antechamber -fi pdb -fo mol2 -i ${root}/parametrization/${system_type}/${mol}/${mol}-original.pdb -o ${mol}-original.mol2 -at gaff -nc ${charge} &> pdb2mol2.log

  if [ "${SLURM}" == "true"  ] ; then
    write_bcc_slurm ${mol}
    sbatch ${mol}.slurm
  else
    # MOL2 to Gaussian (GAFF atom types)
    antechamber -fi mol2 -fo mol2 -i ${mol}-original.mol2 -o ${mol}.mol2 -nc ${charge} -eq 2 -at gaff -pl 20 -c bcc &>prepare_bcc.log
    parmchk -i ${mol}.mol2  -f mol2 -o ${mol}.frcmod  &>parmchk.log
    write_top
  fi
}



write_gaussian_slurm() {
echo "\
#! /bin/bash
# 1 noeud 14 coeurs
#SBATCH -p public
#SBATCH --sockets-per-node=1
#SBATCH --cores-per-socket=14
#SBATCH -t 23:00:00
#SBATCH --mem=16000
#SBATCH --job-name=${mol}_resp

# Environnement par défaut : contient les compilateurs Intel 11
source /b/home/configfiles/bashrc.default

module purge
module load batch/slurm
module load compilers/intel13

module load gaussian/g09
source \$GPROFILE
export GAUSS_SCRDIR=/scratch/job.\$SLURM_JOB_ID 

source \$HOME/software/amber16/amber.sh

# Go to run folder
cd \$SLURM_SUBMIT_DIR

g09 ${mol}.gau

module load compilers/intel15
# Read Gaussian output and write new optimized ligand with RESP charges
antechamber -fi gout -fo mol2 -i ${mol}.log -o ${mol}.mol2 -c resp -s 2 -at gaff -nc ${charge} -pl 20

parmchk -i ${mol}.mol2  -f mol2 -o ${mol}.frcmod  &>parmchk.log

echo \"
source leaprc.gaff
data = loadmol2 ${mol}.mol2
check data
loadamberparams ${mol}.frcmod
saveoff data ${mol}.lib 
saveamberparm data ${mol}.prmtop ${mol}.inpcrd      
quit\" >tleap.in
tleap -f tleap.in &>tleap.log
" > ${mol}.slurm
}


write_bcc_slurm() {
echo "\
#! /bin/bash
# 1 noeud 14 coeurs
#SBATCH -p public
#SBATCH -N 1
#SBATCH -t 23:00:00
#SBATCH --mem=16000
#SBATCH --job-name=${mol}_bcc

# Environnement par défaut : contient les compilateurs Intel 11
source /b/home/configfiles/bashrc.default

# Version of AMBER that works on the OLD Mesocentre computers.
source \$HOME/software/amber16_publicgpu/amber.sh 

# Go to run folder
cd \$SLURM_SUBMIT_DIR

module load compilers/intel15
# Read the MOL2 file, optimize with SQM and write new optimized ligand with AM1-BCC charges
antechamber -fi mol2 -fo mol2 -i ${mol}-original.mol2 -o ${mol}.mol2 -nc ${charge} -eq 2 -at gaff -pl 20 -c bcc &>prepare_bcc.log

parmchk -i ${mol}.mol2  -f mol2 -o ${mol}.frcmod  &>parmchk.log

echo \"
source leaprc.gaff
data = loadmol2 ${mol}.mol2
check data
loadamberparams ${mol}.frcmod
saveoff data ${mol}.lib 
saveamberparm data ${mol}.prmtop ${mol}.inpcrd      
quit\" >tleap.in
tleap -f tleap.in &>tleap.log

" > ${mol}.slurm
}


write_top() {
echo "
source leaprc.gaff
data = loadmol2 ${mol}.mol2
check data
loadamberparams ${mol}.frcmod
saveoff data ${mol}.lib 
saveamberparm data ${mol}.prmtop ${mol}.inpcrd      
quit" >tleap.in
tleap -f tleap.in &>tleap.log
}

prepare_tleap() {
echo "\
source leaprc.gaff

loadoff ../top_gaff/${1}.lib
loadoff ../top_gaff/${2}.lib

loadAmberParams ../top_gaff/${1}.frcmod
loadAmberParams ../top_gaff/${2}.frcmod

host  = loadmol2  ../top_gaff/${1}.mol2
guest = loadmol2  ../top_gaff/${2}.mol2

saveAmberParm host  host/host.prmtop host/host.rst7
saveAmberParm guest guest/guest.prmtop guest/guest.rst7

complex = combine{host,guest}
saveAmberParm complex complex/complex.prmtop complex/complex.rst7

solvatebox host    TIP3PBOX {12, 12, 12} iso 
solvatebox guest   TIP3PBOX {12, 12, 12} iso 
solvatebox complex TIP3PBOX {12, 12, 12} iso 

# Add ions 
AddIons2 host    Na+ 0
AddIons2 host    Cl- 0
AddIons2 guest   Na+ 0
AddIons2 guest   Cl- 0
AddIons2 complex Na+ 0
AddIons2 complex Cl- 0

saveAmberParm host    host/host_box.prmtop       host/host_box.rst7
saveAmberParm guest   guest/guest_box.prmtop     guest/guest_box.rst7
saveAmberParm complex complex/complex_box.prmtop complex/complex_box.rst7

charge host
charge guest
charge complex
quit
"> tleap.in
}


help() {
echo -e "
HGFlow is a bash script to:
1) Automatize parametrization of Host/Guest systems
2) Run Molecular Dynamics Simulations
3) Analise the results

If you follow the standards (RTFM), you'll be happy.

Usage: ${BLUE}HGFlow [-h] ${NC}
"
exit 0
}


# -------------------------------------------------------------------
# Main program
welcome
list_hosts
list_guests
parametrize


echo ${host[@]}
echo ${HOST[@]}
echo ${guest[@]}
echo ${GUEST[@]}
